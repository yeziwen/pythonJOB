//发起socket请求模块

(function () {

    var net = require("net");
    var CONFIG_CONST = require('configconst');

    //短连接请求方法
    exports.onShortSocket = onShortSocket;
    
    //短连接的超时
    var SHORT_SOCKET_TIME_OUT = CONFIG_CONST.getval('SHORT_SOCKET_TIME_OUT');;    

    //允许的请求方法  'IMMED' 表示发送消息后立即返回, 'WAIT'表示等待回复消息
    var CONNECT_TYPES = ['IMMED', 'WAIT'];
    
    /*
    * @method onShortSocket 短连接请求方法,发起请求,获得回应,socket会关闭,下次发送会重新连接
    * @param path {string}  socket path 路径/地址
    * @param data {string}  传递的数据
    * @param callbackSuccess {function}  ( data {string} ) 
    * @param callbackFaile {function} ( err {object} )
    * @param connType {string}  请求的类型　存储在　CONNECT_TYPES　中
    */
    function onShortSocket(path, data, connType, callbackSuccess, callbackFaile){
        

        var client = new net.Socket();
        var rError = {};

        //检查类型是否合法,不合法的请求类型不发送
        if(connType != 'IMMED' && connType !='WAIT'){
            console.log('error connect type, treat as type IMMEDIMMED ');
            rError['message'] = 'invaild connect type ' + connType;
            if(callbackFaile != null){
                callbackFaile(rError);                
            }

        }

        client.on('connect', function () {
            console.log('clent on connect');
            console.log('data : ' + data);
            client.write(data, function () {
                console.log("send data over : " +  data);
                //IMMED　发送数据后，就关闭socket
                if(connType == 'IMMED'){
                    client.end();
                }
            });
        });

        client.on('data', function (buffer) {
            data = buffer.toString();
            if(callbackSuccess != null){
                callbackSuccess(data);                
            }
            //WAIT 获取到响应数据后,关闭socket
            if(connType == 'WAIT'){
                client.end();
            }            
        });

        client.on('end', function () {
            //end事件后，会触发close(
            //注意　如果将 alowhalfopen 设置为true．则不会自动触发close)
            console.log('client on end');
        });

        client.on('error', function (error) {
            if(error){
                console.log(error.toString());                
            }    
        });

        //socket关闭是否成功,若因错误的将调用callbackFaile
        client.on('close', function (isError) {
            if(isError){
                console.log('client closed by error');
                rError['message'] = 'client closed by error';
                if(callbackFaile != null){
                    callbackFaile(rError);                   
                }

            }else{
                console.log('client closed normarly');
            }
        });

        //timeout事件　socket闲置超过指定时间触发，例如　WAIT　时，长时间不返回结果
        client.setTimeout(SHORT_SOCKET_TIME_OUT, function () {
            //超时后关闭socket,按失败处理
            console.log('client timeout event');
            rError['message'] = 'client closed by error';
            if(callbackFaile != null){
                callbackFaile(rError);                   
            }
        });

    
        client.connect(path);
    };

})()